查找算法
==========================
### 顺序查找算法
##### 基本原理:  
线性查找逐一比对,发现相同数值就返回下标
### 二分查找
二分查找只能对有序数组进行查找
##### 基本原理:  
1.首先确定数组的中间下标mid = (left+right)/2
2.将待查找的值value与array[mid]比较,若value>array[mid]比较,则向右递归,否则向左递归.
3.当待查找值==array[mid]返回下标结束递归,若递归完即left>right时,也需退出.
### 插值查找算法
##### 基本原理
自适应mid 根据以下公式快速定位
int mid =  left +(right-left)*(value-array[left])/(array[right]-array[left])
### 斐波那契查找算法
##### 基本原理：
与二分查找与插值查找原理相似，只不过中间结点不再为mid或插值，而是位于黄金分割点附近  
即 mid = left+F[k-1]-1[F代表斐波那契数列]  
由斐波那契数列的性质F[k] = F[k-1]+F[k-2] ===>(F[k]-1) = (F[k-1]-1)+(F[k-2]-1)+1   
则说明若顺序表的长度为 F[k]-1 则可以将该表分成F[k-1]-1与F[k-2]-1两段    
即中间位置mid为F[k-1]-1  
如上所述，每一子段也可以相同的方式分割    
但是顺序表的长度不一定刚好等于F[k-1],所以需要将原顺序表长度增加至F[k-1]  
这里:k值只要能使F[k]-1恰好大于等于n即可,顺序表长度增加后新增位置都赋予n位置的值即可.  
增长赋值可由while(n>F(k)-1){k++;}代码实现  
