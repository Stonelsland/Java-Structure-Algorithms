排序
========================
排序算法是将一组数据按指定顺序进行排列的过程
### 排序的分类
#### 内部排序
将需要处理的所有数据全部加载到内部存储器中进行排序
#### 外部排序
数据量大，无法全部加载到内存中，需要借助外部存储进行排序

### 常见排序算法(内部排序)
#### 插入排序
##### 直接插入排序
###### 基本原理:  
将n个待排序元素看作一个有序表和一个无序表,初始有序表只包含一个元素,无序表中含有n-1个元素,排序过程中
###### 存在问题:  
当需要插入的数较小时,后移次数明显增多,影响效率
##### 希尔排序(缩小增量排序)
###### 基本原理:  
将记录按下标的一定增量分组,对每组使用插入排序算法排序,随着增量逐渐减少,每组包含的关键词越来越多,当增量减至1时,整个文件被分成一组,算法终止。  
当插入数值较小时，提高运行效率，但一般情况下传统交换式希尔排序比直接插入排序的效率更低。  
###### 优化： 
将交换式希尔排序改进为交换式希尔排序，也称为缩小增量排序，优化后效率极高。
#### 选择排序
##### 简单选择排序
###### 基本原理:  
从i=0开始,第i次从array[i]~array[n-1]选取数组中最小值与array[i]交换,总共交换n-1次,得到一个从小到大的有序序列  
###### 规则：
1. 选择排序共有array.length-1轮排序
2. 每一轮排序又是一个循环,循环的规则(代码):  
 2.1 首先假定当前的数就是最小数  
 2.2 和后面的每个数进行比较,若发现比当前数更小的数则重新定义最小的数,并得到下标  
 2.3 当遍历到数组的最后时,就得到本轮最小数和下标  
 2.4 交换  
#### 堆排序
堆排序是利用堆进行选择排序的算法,最坏最好平均时间复杂度均为O(nlbn),也是不稳定排序.  
堆是具有以下性质的完全二叉树:  
每个结点的值都大于或等于(小于或等于)其左右子结点的值(但左右子结点的大小不做要求),称为大(小)顶堆  
大顶堆特点:array[i]>=array[2*i+1]&&array[i]>=array[2*i+2] (i对应第几个结点,i从0开始)  
小顶堆特点:array[i]<=array[2*i+1]&&array[i]<=array[2*i+2] (i对应第几个结点,i从0开始)  
一般升序采用大顶堆降序采用小顶堆  
###### 基本原理:
1.将待排序序列构造为一个大(小)顶堆,此时整个序列的最大(小)值就是堆顶的根节点
2.将其与末尾元素进行交换,此时末尾元素就为最大(小)值
3.再将剩余n-1个元素重新构成一个堆,这样就会得到n个元素的次大(小)值,如此反复执行,便能得到一个有序序列

#### 交换排序
##### 冒泡排序
###### 基本原理:
通过对序列从前向后(从角标小的一端开始)依次比较相邻元素的值,发现逆序则交换
###### 规则:  
1. 排序过程共进行数组长度-1次循环  
2. 每一趟排序的次数逐渐减少
###### 优化:  
因为排序过程中各元素不断接近自己的位置,若一趟比较结束后没有进行交换则证明序列有序,因此要在排序过程中设置判断元素判断是否有序而减少不必要的比较
#### 快速排序
快速排序是对冒泡排序的一种改进  
###### 基本原理：
通过一趟排序将要排序的数据分割成两部分，其中一部分所有数据比另外一部分所有数据都要笑，然后递归进行此方法，直到整个序列变为有序。  

#### 归并排序
###### 基本原理:  
利用归并思想实现排序,采用分治策略:    
分：即是将问题分成一些小的问题然后递归求解
即从数组中间向两边递归分解
治：将分阶段得到的各阶答案拼接在一起
###### 规则:  
1. 创建中转数组temp[],先把左右两边有序的数据填充至temp数组，直到左右两边有一边处理完毕。  
2. 把有剩余数据的一边的数据一次全部填充至temp  
3. 将temp数组的元素copy到array数组中  
#### 基数排序
###### 基本原理:
基数排序属于分配式排序，通过键值的各个位的值，要将排序的元素分配至某些"桶"中,即将整数按位数切割后按每个位数分别比较,达到排序的效果,是桶排序的扩展.  
基数排序是高效率的稳定排序法
###### 规则:  
1. 定义一个二维数组,表示十个桶,每个桶是一个一维数组  
2. 排序:第n轮排序即使将每个元素的倒数第n位数取出放到对应的桶中,然后按照桶的顺序放回原数组,若元素没有当前轮次比较的位数则默认放到第一个桶中.  
3. 轮次由最大的数的位数决定.    
###### 说明:
基数排序算法是空间换时间的经典算法,速度很快,但缺点是占用内存很大,对海量数据排序时,容易造成OutOfMemoryError
###### 排序算法的稳定性
假设在待排序序列中,存在具有多个关键字的记录,若经过排序,这些记录的相对次序保持不变,即在原序列中,r[i] = r[j]
,且r[i]在r[j]之前,而在排序之后,r[i]仍在r[j]之前,则称为排序算法是稳定的,否则为不稳定的.

算法复杂度分析
===============================
算法的时间复杂度
-------------------------------
### 事后统计法
事后统计法存在两个问题：  
1.对算法的运行性能进行评测需要实际运行
2.所得时间统计量依赖于外部环境因素(计算机硬件,软件等)
### 事前统计法
通过分析算法的时间复杂度来判断
### 时间频度T(n)
一个算法花费的时间与算法中语句的执行次数成正比,一个算法中语句执行次数称为时间频度(语句频度)
当n增大时,T(n)中的常数项,低次项以及系数都可以忽略
T(n)不同时,时间复杂度不一定不同
如:T(n) = n^2+7n+6与T(n)=3n^2+2n+2的时间频度不同
但根据当n增大时,T(n)中的常数项,低次项以及系数都可以忽略的原则,则时间复杂度都为O(n^2)
### (渐进)时间复杂度
时间频度T(n)为函数中基本操作语句的重复执行次数,若存在一个辅助函数f(n),使得当n趋向于无穷大时
T(n)/f(n)的极限值趋向于非零常数,则称f(n)为T(n)的同数量级函数,则有T(n)=O(f(n)).
O(f(n))则称为算法的渐进时间复杂度,简称时间复杂度

### 计算时间复杂度的方法
只保留T(n)中最高阶项并去除系数即得出时间复杂度

###平均时间复杂度与最坏时间复杂度
平均时间复杂度为所有可能的实例以等概率出现的情况下该算法的运行时间  
最坏时间复杂度则是算法在任何输入实例的情况下运行时间的界限   
最坏时间复杂度保证了算法的运行时间不会比最坏情况更长  
平均时间复杂度与最坏时间复杂度是否相等与算法有关  

算法的空间复杂度
-----------------------
算法的空间复杂度定义为该算法所耗费的存储空间,也是问题规模为n的函数
空间复杂度是对一个算法在运行过程中临时占用的存储空间大小的量度
在做算法分析时主要讨论时间复杂度,因为从用户体验来看,程序执行的速度显然更为重要
所以类似于Redis等缓存产品及很多排序算法的本质就是空间换取时间.

排序算法性能分析比较：
----------------------------------
##### lb == log2(x)

    排序方法    最好时间 平均时间 最坏时间 最坏辅助空间 稳定性 

    插入排序      O(n)   O(n^2)  O(n^2)     O(1)    稳定

    希尔排序     O(nlbn) O(nlbn) O(nlbn)    O(1)    不稳定

    选择排序     O(n^2)  O(n^2)  O(n^2)     O(1)    不稳定
    
     堆排序      O(nlbn) O(nlbn) O(nlbn)    O(1)    不稳定
    
    冒泡排序     O(n)    O(n^2)  O(n^2)     O(1)    稳定

    快速排序     O(nlbn) O(nlbn) O(n^2)     O(n)    不稳定
    
    归并排序     O(nlbn) O(nlbn) O(nlbn)    O(n)    稳定
    
    基数排序     O(mn)   O(mn)   O(mn)      O(n)    稳定    
    




 